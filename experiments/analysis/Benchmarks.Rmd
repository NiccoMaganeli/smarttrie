---
title: "SmartTrie - Project Benchmarks"
output: 
  html_notebook: 
    code_folding: none
    toc: yes
  pdf_document: 
    fig_crop: no
    toc: yes
---

```{r predef, warning=FALSE, include=FALSE}
library(stringr)
library(dplyr)
library(ggplot2)

load_ycsb_througput = function(log_file_path) {
  ycsb_lines = regex(
    paste(
      "(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}:\\d{3}).*",
      "\\[UPDATE:",
      "Count=(.*),",
      "Max=(.*),",
      "Min=(.*),",
      "Avg=(.*),",
      "90=(.*),",
      "99=(.*),",
      "99.9=(.*),",
      "99.99=(.*)]"
    )
  )
  
  ycsb = str_match(readLines(log_file_path), ycsb_lines)
  ycsb = ycsb[!is.na(ycsb[, 1]),]
  ycsb = ycsb[,-1]
  colnames(ycsb) = c("ts",
                     "throughput",
                     "max",
                     "min",
                     "avg",
                     "p90",
                     "p99",
                     "p999",
                     "p9999")
  
  ycsb =
    as_tibble(ycsb) %>%
    mutate(ts = sub("(\\d{2}):(\\d{3})", "\\1.\\2", ts)) %>%
    mutate_at(vars(ts), as.POSIXct) %>%
    mutate_at(vars(throughput, max, min, avg, p90, p99, p999, p9999),
              as.numeric)
}

load_checkpoint_marks = function(server_log_path, start_ts, end_ts, version) {
  if (version == 0) {
    checkpoint_start = "Starting replica checkpoint serialization"
    checkpoint_stop = "Next command occurred after \\d+s since last checkpoint"
  } else {
    checkpoint_start = "Starting replica checkpoint"
    checkpoint_stop = "Checkpoint created after \\d+s"
  }
  
  checkpoint_lines = regex(
    paste0(
      "(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3}).*",
      "(",
      checkpoint_start,
      "|",
      checkpoint_stop,
      ")"
    )
  )
  
  checkpoints = str_match(readLines(server_log_path), checkpoint_lines)
  checkpoints = checkpoints[!is.na(checkpoints[, 1]),]
  checkpoints = checkpoints[,-1]
  colnames(checkpoints) = c("ts", "event")
  
  checkpoints =
    as_tibble(checkpoints) %>%
    mutate(event = sub(checkpoint_start, "start", event)) %>%
    mutate(event = sub(checkpoint_stop, "stop", event)) %>%
    mutate_at(vars(ts), as.POSIXct) %>%
    mutate_at(vars(event), as.factor) %>%
    filter(ts >= start_ts & ts <= end_ts)
}

plot_througput_vs_checkpoints = function(title, ycsb_log, server_log, version=1) {
  ycsb = load_ycsb_througput(ycsb_log)
  checkpoints = load_checkpoint_marks(server_log, head(ycsb$ts), last(ycsb$ts), version)
  
  ggplot() +
    geom_line(data = ycsb, aes(ts, throughput)) +
    geom_vline(data = checkpoints,
               aes(xintercept = ts, color = event),
               linetype = "dashed") +
    labs(title = title, 
         x = "Time",
         y = "Througput (requests/second)") +
    scale_color_discrete(name = "Checkpoints")
}
```

# Experimentos

## 2020-10-09 - Baseline

Criação da baseline com aplicação tradicional. Configurações relevantes:

| Configuração | Valor | Observação |
|---|---|---|
| Servidores vs Clientes | 1/1 | Node 91-92 |
| Escrita vs Leitura | 100/0 | |
| Chaves | 500000 | |
| Requests | 500000 | |
| Bytes/Registro | 4kb | |
| Periodo de Checkpoints | 100000 | |
| Periodo de Asyncronos | Não | |
| Estrutura de dados | java.util.TreeMap | |
| Commit | 26544ab | |

Após a carga de dados, o estado em memória atingiu 1967MB (1.92G). Checkpoints levaram entre 30-40 segundos. A vazão da baseline parece irregular nos períodos entre checkpoints, o que motivou a execução com outros tipos de garbage collector. Por padrão a JVM 11 utiliza o algoritmo G1, porém, ZGC aparenta ser o algoritmo mais estável para esta aplicação. Dois bugs foram encontrados: 1) ao tentar executar a aplicação com 1M de chaves, a carga de dados é completada mas, o benchmark tem timeouts em praticamente todas as requisições; 2) ao reiniciar o servidor mantendo os dados persistidos, praticamente todas as requisições resultam em timeout (similar ao problema 1).

```{r experiment-2020-10-09-baseline, echo=FALSE, warning=FALSE}
plot_througput_vs_checkpoints(
  "Baseline",
  "../results/20201009T132837/node92/tmp/SmartTrie/logs/benchmark.log",
  "../results/20201009T132837/node91/tmp/SmartTrie/logs/app.log",
  version=0
)
```

```{r experiment-2020-10-09-parallel-gc, echo=FALSE, warning=FALSE}
plot_througput_vs_checkpoints(
  "Baseline + ParallelGC",
  "../results/20201009T140936/node92/tmp/SmartTrie/logs/benchmark.log",
  "../results/20201009T140936/node91/tmp/SmartTrie/logs/app.log",
  version=0
)
```

```{r experiment-2020-10-09-parallel-zgc, echo=FALSE, warning=FALSE}
plot_througput_vs_checkpoints(
  "Baseline + ZGC",
  "../results/20201009T143012/node92/tmp/SmartTrie/logs/benchmark.log",
  "../results/20201009T143012/node91/tmp/SmartTrie/logs/app.log",
  version=0
)
```

```{r local, echo=FALSE, warning=FALSE}
plot_througput_vs_checkpoints(
  "Tree-Map",
  "../../logs/tree-map-benchmark.log",
  "../../logs/tree-map-app.log"
)
```

```{r local, echo=FALSE, warning=FALSE}
plot_througput_vs_checkpoints(
  "Hash-Map",
  "../../logs/hash-map-benchmark.log",
  "../../logs/hash-map-app.log"
)
```

```{r local, echo=FALSE, warning=FALSE}
plot_througput_vs_checkpoints(
  "Trie-Map",
  "../../logs/trie-map-benchmark.log",
  "../../logs/trie-map-app.log"
)
```